puts "Врага какого персонажа вы хотите узнать?"
puts "\"Бэтмен, Шерлок Холмс, Железный Человек, Моцарт\"\n\n"

#Врага какого персонажа вы хотите узнать?
hero = STDIN.gets.chomp

# Объявим новый ассоциативный массив с парами герой-антигерой
heros_antiheros = {
  "Бэтмен" => "Джокер",
  "Холмс" => "Мориарти",
  "Железный" => "Капитан",
}

# Динамически после объявления добавили в него пару Моцарт - Сальери
heros_antiheros["Моцарт"] = "Сальери"

# Потом тут же динамически удалили эту пару по значению ключа
heros_antiheros.delete("Моцарт")

#Пока в переменной user_word ничего не будет, а именно: nil - ничего, пустота; "" - пустая строка,
# то будет возвращаться переменная user_word, которая ждет пользователький ввод
while hero == nil || hero == ""
  hero = STDIN.gets.chomp
end

# Проверка на наличие ключа в хэще
if heros_antiheros.has_key?(hero)
  puts "Враг этого героя: #{heros_antiheros[hero]}"
else
  puts "Не удалось найти героя!"
end

# Выводим все ключи в хэше, подключая метод join,
# поскольку join принимает на вход массив, образованный от keys, а возвращает строку
puts "\nВсе герои: #{heros_antiheros.keys.join(", ")}"





